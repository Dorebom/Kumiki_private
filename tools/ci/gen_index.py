
#!/usr/bin/env python3
import os, re, sys, yaml, datetime, json, argparse
from pathlib import Path

def read_frontmatter(md_path: Path):
    try:
        text = md_path.read_text(encoding="utf-8")
        if text.startswith('---'):
            end = text.find('\n---', 3)
            if end != -1:
                fm_text = text[3:end]
                fm = yaml.safe_load(fm_text) or {}
                body = text[end+4:]
                return fm, body
    except Exception:
        pass
    return {}, ''

def detect_cr_num(name):
    m = re.search(r"CR[-_]?(\d+)", name, re.I)
    return int(m.group(1)) if m else None

def collect_entries(concept_dir, docs_root):
    md_files = [os.path.join(concept_dir, f) for f in os.listdir(concept_dir) if f.endswith('.md')]
    entries = []
    for p in md_files:
        fm, _ = read_frontmatter(Path(p))
        title = fm.get('title') or os.path.splitext(os.path.basename(p))[0]
        idv = fm.get('id', '')
        status = fm.get('status', '')
        ver = fm.get('version', '')
        updated = fm.get('updated', '')
        created = fm.get('created', '')
        tags = fm.get('tags', [])
        rel = os.path.relpath(p, docs_root).replace('\\', '/')
        crn = detect_cr_num(os.path.basename(p))
        entries.append({
            'rel': rel, 'title': title, 'id': idv, 'status': status,
            'version': ver, 'updated': updated, 'created': created, 'tags': tags, 'crn': crn
        })
    return entries

def sort_entries(entries, nav_order_path):
    desired = []
    if os.path.exists(nav_order_path):
        try:
            navcfg = yaml.safe_load(open(nav_order_path, 'r', encoding='utf-8')) or {}
            desired = navcfg.get('order') or []
        except Exception:
            desired = []
    order_index = {path: i for i, path in enumerate(desired)}
    entries_sorted = sorted(entries, key=lambda e: (
        order_index.get(e['rel'], 10000 + (e['crn'] or 9999)),
        e['rel']
    ))
    if not os.path.exists(nav_order_path):
        with open(nav_order_path, 'w', encoding='utf-8') as f:
            yaml.safe_dump({
                'order': [e['rel'] for e in entries_sorted],
                'notes': "任意順に固定したい場合は 'order' の配列で並べ替えてください。相対パス（docs/ からの）を指定。"
            }, f, allow_unicode=True, sort_keys=False)
    return entries_sorted

def _parse_date(s):
    if not s: return None
    try:
        if len(s) >= 10:
            return datetime.date.fromisoformat(s[:10])
    except Exception:
        return None
    return None

def _fmt_date(d):
    return d.isoformat()

def compute_created_updated(entries, existing_fm):
    today = datetime.date.today()
    if isinstance(existing_fm, dict) and existing_fm.get('created'):
        try:
            created = _parse_date(existing_fm['created']) or today
        except Exception:
            created = today
    else:
        created_candidates = [_parse_date(e.get('created','')) for e in entries if e.get('created')]
        created_candidates = [d for d in created_candidates if d is not None]
        created = min(created_candidates) if created_candidates else today

    updated_candidates = [_parse_date(e.get('updated','')) for e in entries if e.get('updated')]
    updated_candidates = [d for d in updated_candidates if d is not None]
    existing_updated = None
    if isinstance(existing_fm, dict) and existing_fm.get('updated'):
        existing_updated = _parse_date(existing_fm['updated'])
    if updated_candidates:
        updated = max(updated_candidates)
    else:
        updated = existing_updated or created
    return created, updated

def write_index(entries_sorted, index_path: Path):
    fm_prev, _ = read_frontmatter(index_path) if index_path.exists() else ({}, '')
    created, updated = compute_created_updated(entries_sorted, fm_prev)
    version = fm_prev.get('version', '0.1.0') if isinstance(fm_prev, dict) else '0.1.0'
    status = fm_prev.get('status', 'stable') if isinstance(fm_prev, dict) else 'stable'

    fm = {
        'id': 'DOC-INDEX',
        'title': 'Kumiki 概要（00_concept）',
        'type': 'overview',
        'status': status,
        'version': version,
        'created': _fmt_date(created),
        'updated': _fmt_date(updated or created),
        'tags': ['index','auto-generated']
    }
    body_lines = []
    body_lines.append('<!-- AUTO-GENERATED by tools/ci/gen_index.py -->')
    body_lines.append('# Kumiki — コンセプト要件集')
    body_lines.append('')
    body_lines.append('## 章立て（固定順）')
    for e in entries_sorted:
        body_lines.append(f"- [{e['title']}]({e['rel']})")
    body_lines.append('')
    body_lines.append('## 一覧（メタ情報）')
    body_lines.append('| CR | タイトル | ステータス | 版 | 更新日 | タグ |')
    body_lines.append('|---:|---|---|---|---|---|')
    for e in entries_sorted:
        cr = f"CR-{e['crn']}" if e['crn'] is not None else (e['id'] or '')
        tags = ', '.join(map(str, e.get('tags', []))) if e.get('tags') else ''
        body_lines.append(f"| {cr} | [{e['title']}]({e['rel']}) | {e.get('status','')} | {e.get('version','')} | {e.get('updated','')} | {tags} |")
    index_path.parent.mkdir(parents=True, exist_ok=True)
    with open(index_path, 'w', encoding='utf-8') as f:
        f.write('---\n')
        f.write(yaml.safe_dump(fm, allow_unicode=True, sort_keys=False))
        f.write('---\n\n')
        f.write('\n'.join(body_lines))

def write_mkdocs(entries_sorted, mkdocs_path, docs_root='docs'):
    nav = [{ e['title']: e['rel'] } for e in entries_sorted]
    cfg = {
        'site_name': 'Kumiki Docs',
        'site_description': 'Kumiki ドキュメント（00_concept 版）',
        'site_url': 'https://example.com',
        'theme': {
            'name': 'material',
            'language': 'ja',
            'features': [
                'navigation.instant','navigation.tracking','navigation.sections','navigation.top','content.code.copy',
            ],
        },
        'docs_dir': docs_root,
        'use_directory_urls': True,
        'plugins': ['search'],
        'markdown_extensions': [
            'admonition','toc','tables','attr_list','def_list','md_in_html',
            {'pymdownx.superfences': {}},{'pymdownx.details': {}},{'pymdownx.tabbed': {'alternate_style': True}},
        ],
        'nav': [
            {'00_Concept': nav}
        ]
    }
    with open(mkdocs_path, 'w', encoding='utf-8') as f:
        yaml.safe_dump(cfg, f, allow_unicode=True, sort_keys=False)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--docs-root', default='docs')
    ap.add_argument('--concept-dir', default=os.path.join('docs','00_concept'))
    ap.add_argument('--nav-config', default=os.path.join('tools','docops_cli','config','nav_order.yml'))
    ap.add_argument('--index-out', default=os.path.join('docs','index.md'))
    ap.add_argument('--mkdocs-out', default='mkdocs.yml')
    ap.add_argument('--update-mkdocs', action='store_true', help='mkdocs.yml も更新する')
    args = ap.parse_args()

    entries = collect_entries(args.concept_dir, args.docs_root)
    entries_sorted = sort_entries(entries, args.nav_config)
    write_index(entries_sorted, Path(args.index_out))
    if args.update_mkdocs:
        write_mkdocs(entries_sorted, args.mkdocs_out, docs_root=args.docs_root)

    result = {
        'written': [args.index_out] + ([args.mkdocs_out] if args.update_mkdocs else []),
        'count': len(entries_sorted),
        'nav_first': entries_sorted[0]['title'] if entries_sorted else None
    }
    print(json.dumps(result, ensure_ascii=False))

if __name__ == '__main__':
    try:
        import yaml  # noqa
    except Exception:
        print('PyYAML が必要です: pip install pyyaml', file=sys.stderr)
        sys.exit(1)
    main()
